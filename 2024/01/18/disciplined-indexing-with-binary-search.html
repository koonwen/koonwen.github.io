<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Disciplined indexing with Binary-search | (core dumped)</title>
<meta name="generator" content="Jekyll v3.9.5" />
<meta property="og:title" content="Disciplined indexing with Binary-search" />
<meta name="author" content="Koon Wen Lee" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="The topic for today’s article was churned up out of frustration thanks to the classic “off-by-one” error. The especially annoying thing is that Binary-search is one of those elementary algorithms that you should be able to produce without hiccup. Except that it’s happened now a couple times that I spend way too long figuring out where I’m messing up the indices. With this article, I put forth a set of “rules” to think about when implementing binary search in future." />
<meta property="og:description" content="The topic for today’s article was churned up out of frustration thanks to the classic “off-by-one” error. The especially annoying thing is that Binary-search is one of those elementary algorithms that you should be able to produce without hiccup. Except that it’s happened now a couple times that I spend way too long figuring out where I’m messing up the indices. With this article, I put forth a set of “rules” to think about when implementing binary search in future." />
<link rel="canonical" href="https://koonwen.github.io/2024/01/18/disciplined-indexing-with-binary-search.html" />
<meta property="og:url" content="https://koonwen.github.io/2024/01/18/disciplined-indexing-with-binary-search.html" />
<meta property="og:site_name" content="(core dumped)" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-01-18T12:33:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Disciplined indexing with Binary-search" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Koon Wen Lee"},"dateModified":"2024-01-18T12:33:00+00:00","datePublished":"2024-01-18T12:33:00+00:00","description":"The topic for today’s article was churned up out of frustration thanks to the classic “off-by-one” error. The especially annoying thing is that Binary-search is one of those elementary algorithms that you should be able to produce without hiccup. Except that it’s happened now a couple times that I spend way too long figuring out where I’m messing up the indices. With this article, I put forth a set of “rules” to think about when implementing binary search in future.","headline":"Disciplined indexing with Binary-search","mainEntityOfPage":{"@type":"WebPage","@id":"https://koonwen.github.io/2024/01/18/disciplined-indexing-with-binary-search.html"},"url":"https://koonwen.github.io/2024/01/18/disciplined-indexing-with-binary-search.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://koonwen.github.io/feed.xml" title="(core dumped)" /><script>
if(!(window.doNotTrack === "1" || navigator.doNotTrack === "1" || navigator.doNotTrack === "yes" || navigator.msDoNotTrack === "1")) {
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-NNNNNNNN-N', 'auto');
  ga('send', 'pageview');
}
</script>
  
</head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">(core dumped)</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/blog">Blog</a><a class="page-link" href="/projects">Projects</a><a class="page-link" href="/resume">Resume</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

    <header class="post-header">
        <h1 class="post-title p-name" itemprop="name headline">Disciplined indexing with Binary-search</h1>
        <p class="post-meta">
            <time class="dt-published" datetime="2024-01-18T12:33:00+00:00" itemprop="datePublished">Jan 18, 2024
            </time></p>
    </header>

    
    <img class="img-fluid" src="/assets/img/bin-search-cover.jpg" alt="Cover photo">
    

    <div class="post-content e-content" itemprop="articleBody">
        <h5>Pre-requisite knowledge assumed: <strong> Python | Binary Search </strong></h5>
        <h1> — </h1>
	<ul id="toc" class="toc__list">
<li class="toc-entry toc-h2"><a href="#binary-search-a-summary">Binary Search: a summary</a></li>
<li class="toc-entry toc-h2"><a href="#bisect--binary-search">Bisect &gt; Binary search</a></li>
<li class="toc-entry toc-h2"><a href="#termination">Termination</a></li>
<li class="toc-entry toc-h2"><a href="#all-in-all">All in all</a></li>
</ul>
        <p>The topic for today’s article was churned up out of frustration thanks
to the classic “off-by-one” error. The especially annoying thing is
that Binary-search is one of those elementary algorithms that you
should be able to produce without hiccup. Except that it’s happened
now a couple times that I spend way too long figuring out where I’m
messing up the indices. With this article, I put forth a set of
“rules” to think about when implementing binary search in future.</p>

<h2 id="binary-search-a-summary">Binary Search: a summary</h2>
<p>Binary search is a quick way to search technique given an <strong>ordered
collection</strong>. The search runs by looking at the arbitrary midpoint and
checking if we should continue the search to the left or to the
right. We do this same process until we end up with just one element,
at which point we can decide that the search was successful or
not. Being able to halve the problem every time leads to a fantastic
time complexity of O(log(n)).</p>

<h2 id="bisect--binary-search">Bisect &gt; Binary search</h2>
<p>One thing I learnt about approaching Binary search problems, is that
you should think about them instead as a bisection problems. This
means that rather than viewing the algorithm as a search method, we
look at it from the vantage point of a method to reduce our search
space. This subtle shift in mind-set arrives at a different
perspective of our usual “We use Binary search to look for an element”
to “We use Binary search to throw away the bits that don’t matter”.</p>

<p>Still confused? Let’s put it into concrete terms. Given some sorted
array <code class="language-plaintext highlighter-rouge">arr</code> of elements, identify if the element <code class="language-plaintext highlighter-rouge">k</code> is in the
array. If we are thinking about this in terms of bisection, our
question is now: “identify the smallest index where the element is
equal to <code class="language-plaintext highlighter-rouge">k</code>”</p>

<p>Here are some example arrays where we’d expect the final index to land</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>k = 3

Case1:[1,2,3,4,5,6]
           ^
Case2:[3,3,3,3,3,3]
       ^
Case3:[1,2,3,3,3,4]
           ^
Case4:[1,1,1,1,1,1]
                   ^
Case5:[4,4,4,4,4,4]
       ^
</code></pre></div></div>

<p>Cases1-3 are fairly self explanatory, we landed on the index where the
element under the index is equal to 3 <code class="language-plaintext highlighter-rouge">and</code> is also the earliest 3 we
encounter if we traverse the list from left to right. How about Case4?
What if 3 is not in the list? Then by our bisection criteria, we
should rightly land outside the list, Translated into indices, we only
have <code class="language-plaintext highlighter-rouge">0 - N-1</code> index elements, but we will allow our search to also
land on <code class="language-plaintext highlighter-rouge">N</code>. This means that if our index is on <code class="language-plaintext highlighter-rouge">N</code> we can conclude
that <code class="language-plaintext highlighter-rouge">k</code> is not in the array.</p>

<p>However, look at Case5. Although <code class="language-plaintext highlighter-rouge">3</code> is not in the list, the final
index lands on position <code class="language-plaintext highlighter-rouge">0</code> (In accordance to how expect the search to
move leftwards rather than to the right as in Case4). This is a
problem, shouldn’t we also allow <code class="language-plaintext highlighter-rouge">-1</code> to be a possible index to land
on? The answer is yes but mostly no. Yes, in that we should be landing
outside the array bounds following the bisection principle. No because
this will complicate how we decide to bisect the array as well as how
we find divide to find the midpoint. The workaround is to have two
checks at the end:</p>

<ul>
  <li>Make sure you’re within array bounds</li>
  <li>if you’re within, check that the element under my index is equal to
<code class="language-plaintext highlighter-rouge">k</code></li>
</ul>

<h2 id="termination">Termination</h2>
<p>Another thing to make sure to get right, is that the algorithm doesn’t
get stuck looping on the same index. The key to this are three things,
the <strong>loop invariant</strong>, how you find the <strong>midpoint</strong> and how you get the
new <strong>array bounds</strong>. These three <strong>MUST</strong> be compatible to ensure
that your algorithm will eventually hit the base case. One combination
that works is:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">loop</span> <span class="n">invariant</span><span class="p">:</span> <span class="n">lo</span> <span class="o">&lt;</span> <span class="n">hi</span>

<span class="n">midpoint</span><span class="p">:</span> <span class="p">(</span><span class="n">lo</span> <span class="o">+</span> <span class="n">hi</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>    <span class="c1"># floor division
</span>
<span class="n">array</span> <span class="n">bounds</span><span class="p">:</span> <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">midpoint</span><span class="p">]</span> <span class="o">==</span> <span class="n">k</span><span class="p">:</span>
                  <span class="n">hi</span> <span class="o">=</span> <span class="n">midpoint</span>
              <span class="k">else</span><span class="p">:</span>
                  <span class="n">lo</span> <span class="o">=</span> <span class="n">midpoint</span> <span class="o">+</span> <span class="mi">1</span>
</code></pre></div></div>

<p>Let’s go through why this work, starting with the array bounds. Given
our bisection criteria again, if the element we are currently on is
equal to <code class="language-plaintext highlighter-rouge">k</code>, we may or may not be on the smallest index. Eitherways
we have to keep it’s index <strong>inside</strong> the array bounds so we only
update <code class="language-plaintext highlighter-rouge">hi = midpoint</code>. In the <code class="language-plaintext highlighter-rouge">else</code> case, we know for certainty that
we can exclude the current index, therefore the ‘+1’.</p>

<p>For the midpoint calculation, we use floor division which gives us the
following properties. If the number of elements we are considering is
<code class="language-plaintext highlighter-rouge">odd</code> we have an true midpoint. Floor division gives the correct index
of that midpoint when we use indices bounds. E.g. <code class="language-plaintext highlighter-rouge">(0 + 4) // 2 = 2</code>.
<strong>index 2</strong> in the <code class="language-plaintext highlighter-rouge">[1,2,3,4,5]</code> is the element 3, perfectly in the
middle. However, if we are performing the division for an even number
of elements, then we land to the left of the middle. So the index that
we land on for the array <code class="language-plaintext highlighter-rouge">[1,2,3,4]</code>, would be <code class="language-plaintext highlighter-rouge">(0+3) // 2 = 1</code>
<strong>index 1</strong>, which is <strong>element 2</strong>.</p>

<p>With the above constraints, the only way we can “get stuck” is if we
always calculate the same midpoint and the value under the midpoint
index is equal to <code class="language-plaintext highlighter-rouge">k</code>, so that <code class="language-plaintext highlighter-rouge">hi</code> remains the same. We can narrow
this down further to when <code class="language-plaintext highlighter-rouge">lo</code> and <code class="language-plaintext highlighter-rouge">hi</code> are next to each other since
our loop invariant exits when <code class="language-plaintext highlighter-rouge">lo == hi</code>. Now we just have to realize
that our previous argument said that if we are considering an even
number of elements, we always end up to the left of the middle. That
means that our <code class="language-plaintext highlighter-rouge">hi</code> will always progress to equal <code class="language-plaintext highlighter-rouge">lo</code> and terminate
the loop invariant. Nice!</p>

<h2 id="all-in-all">All in all</h2>
<p>Now why go through all that effort to turn the binary search into
bisection? For a lot of questions I’ve run into, binary search is
often employed to find bisection. E.g “Find the earliest occurrence in
a git history of a bad commit”. In such cases, I mess up by being
“one-off” because the search criteria in my head is looking for an
exact point. Trying to edit it after is like working out if the three
factors for termination play nice which is a disaster. Bisection works
in both cases so it’s much better to go with one disciplined approach.</p>

<p>Our final solution looks something like this that can be modified
based on the specific algorithm</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">bin_search</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">hi</span><span class="p">)</span>   <span class="c1"># We include the len(hi) index as discussed earlier
</span>    <span class="k">while</span> <span class="n">lo</span> <span class="o">&lt;</span> <span class="n">hi</span><span class="p">:</span>
        <span class="n">midpoint</span> <span class="o">=</span> <span class="p">(</span><span class="n">lo</span> <span class="o">+</span> <span class="n">hi</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">midpoint</span><span class="p">]</span> <span class="o">==</span> <span class="n">k</span><span class="p">:</span>
            <span class="n">hi</span> <span class="o">=</span> <span class="n">midpoint</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lo</span> <span class="o">=</span> <span class="n">midpoint</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">lo</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="ow">and</span> <span class="n">arr</span><span class="p">[</span><span class="n">lo</span><span class="p">]</span> <span class="o">==</span> <span class="n">k</span>
</code></pre></div></div>

<p>Checking either <code class="language-plaintext highlighter-rouge">lo</code> or <code class="language-plaintext highlighter-rouge">hi</code> will work because it is always the case
that they will be equal to each other.</p>

<p>Of course there are different ways to design this focusing on
different bisection criteria. But since I’ve gone through the effort
to prove to myself that this combination works, I’ll take this as my
template solution.</p>

<h5 id="a-lot-of-my-ideas-here-are-inspired-by-this-great-article">A lot of my ideas here are inspired by this great <a href="http://coldattic.info/post/95/">article</a>.</h5>


    </div><a class="u-url" href="/2024/01/18/disciplined-indexing-with-binary-search.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
    <data class="u-url" href="/"></data>

    <div class="wrapper">

        <!-- <h2 class="footer-heading">(core dumped)</h2> -->

        <div class="footer-col-wrapper">
            <div class="footer-col footer-col-1">
                <ul class="contact-list">
                    <li class="p-name">Koon Wen Lee</li><li><a class="u-email" href="mailto:%6B%6F%6F%6E%77%65%6E@%67%6D%61%69%6C.%63%6F%6D">koonwen@gmail.com</a></li></ul>
            </div>

            <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/koonwen"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">koonwen</span></a></li><li><a href="https://www.linkedin.com/in/koonwen-lee-b349b1175"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#linkedin"></use></svg> <span class="username">koonwen-lee-b349b1175</span></a></li><li><a href="https://www.twitter.com/koonwen"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">koonwen</span></a></li><li><a href="/feed.xml"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#rss"></use></svg> <span>rss</span></a></li></ul>
</div>

            <div class="footer-col footer-col-3">
                <p>Portfolio and Blog
</p>
            </div>
        </div>

    </div>

</footer>
</body>

</html>
